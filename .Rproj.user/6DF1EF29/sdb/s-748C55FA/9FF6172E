{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Graphic Analysis of Lottery Data with Boxplots\"\nauthor: \"coop711\"\ndate: \"2015년 3월 14일\"\noutput: html_document\n---\n\nScatter Plot\n-----------------\n\n- 이제 두 변수의 산점도를 그려보자. 산점도는 관찰값의 $x$좌표와 $y$좌표를 평면 상에 나타낸 것이다. lottery 자료의 첫날 당첨번호와 당첨금액은 `lottery[1,]` 이므로, 각 좌표를  평면상에 나타내면 text() 함수를 \n이용하여 \n\n```{r fig.width=8, fig.height=4}\nload(\"./lottery.RData\")\nattach(lottery)\npar(mfrow=c(1,2))\nplot(lottery[1,], xlim=c(0,1000), ylim=c(0,1000), axes=F, xlab=\"Number\", ylab=\"Payoff\")\naxis(side=1, at=c(0,500,810,1000), labels=c(0,500,810,1000))\naxis(side=2, at=c(0,190, 500 ,1000), labels=c(0,190, 500,1000))\ntext(lottery[1,], labels=c(\"(810, 190)\"), pos=1)\narrows(x0=810,y0=190,x1=810,y1=0, code=2, length=0.2)\narrows(x0=810,y0=190,x1=0,y1=190, code=2, length=0.2)\n```\n\n-  당첨번호 0, 499, 999에 해당하는 당첨금액을 찾아서 평면 상에 나타내면?\n\n```{r}\nid.0<-which(lottery$lottery.number==0)\nlottery[id.0,]\nid.499<-which(lottery$lottery.number==499)\nlottery[id.499,]\nid.999<-which(lottery$lottery.number==999)\nlottery[id.999,]\n```\n\n- 파악한 좌표를 평면 상에 points()를 이용하여 표시하고, text() 로 라벨을 붙임.\n\n```{r fig.width=8, fig.height=4}\npar(mfrow=c(1,2))\nplot(lottery[c(id.0,id.499,id.999),], xlim=c(0,1000), ylim=c(0,1000), axes=F, xlab=\"Number\", ylab=\"Payoff\")\naxis(side=1, at=c(0,500,810,1000), labels=c(0,500,810,1000))\naxis(side=2, at=c(0,190, 500 ,1000), labels=c(0,190, 500,1000))\ntext(lottery[id.0,], labels=\"(0, 96)\", pos=4)\ntext(lottery[c(id.499,id.999),], labels=c(\"(499, 869.5)\", \"(499, 247.5)\", \"(999, 239)\"), pos=2)\n```\n\n\n- 흐름을 파악하기 위하여 local smoother 를 적용. 최소제곱법으로 구한 1차회귀선과 비교. legend()를 이용하여 범례를 만들 때에도 좌표를 주는 것 이외의 방법을 알아 둘 것.\n\n```{r fig.width=8, fig.height=6}\nplot(lottery.number, lottery.payoff,pch=20, ylim=c(0,1000))\nabline(lsfit(lottery.number, lottery.payoff)$coef)\nabline(h=seq(0,1000,by=250),lty=2)\nabline(v=seq(0,1000,by=100),lty=2)\nabline(lsfit(lottery.number, lottery.payoff)$coef)\nlines(lowess(lottery.number,lottery.payoff, f=1/3),col=\"blue\")\nlines(lowess(lottery.number,lottery.payoff, f=2/3),col=\"red\")\nlegend(x=0,y=1000, lty=1, col=c(\"black\",\"blue\",\"red\"), legend=c(\"lsfit\",\"lowess, f=1/3\",\"lowess, f=2/3\"))\n```\n\n- 이제는 boxplot을 이용하여 자료의 특징을 살펴보자. 단순히 당첨번호와 당첨금액의 boxplot을 그려보는 것은 fivenum()을 확인하는 데 지나지 않으므로 산점도로부터 파악한 사실들을 일깨워 보자. 우선, 다섯 숫자 요약을 살펴보면\n\n```{r}\napply(lottery, 2, fivenum)\n```\n\n- 당첨번호와 당첨금액의 boxplot을 나란히 그려보면\n\n```{r fig.width=8, fig.hegith=4}\npar(mfrow=c(1,2))\nboxplot(lottery.number, main=\"Numbers Drawn\")\nboxplot(lottery.payoff, main=\"Payoff in Dollars\")\n```\n\n- 당첨번호와 당첨금액의 관계를 boxplot()을 이용하여 살펴보려면 먼저 당첨번호를 계급으로 나누어야 함. 이때 cut() 을 이용하여 factor를 생성하게 됨. 먼저 혼동을 없애기 위해 lottery를 lottery.fac에 저장하고, classes.10를 생성. 이때 구간의 모양을 같게 하기 위하여 마지막 값을 어떻게 설정하였는지 유의. \n\n```{r}\nlottery.fac<-lottery\nlottery.fac$classes.10<-cut(lottery.fac$lottery.number, breaks=c(seq(0,900, by=100),999), right=F)\nhead(lottery.fac)\ndetach()\nattach(lottery.fac)\n```\n\n- 이 상태로 당첨번호와 당첨금액의 관계를 boxplot으로 나타내면 관계는 명확히 파악할 수 있으나 $x$축이 너무 번잡하게 됨.\n\n```{r fig.width=8, fig.height=6}\nboxplot(lottery.payoff~classes.10, data=lottery.fac)\n```\n\n- classes.10 의 labels 들을 구간의 첫 글자로 만들어 주고, 다시 그리면.\n\n```{r fig.width=8, fig.height=6}\nlottery.fac$classes<-factor(classes.10, labels=0:9)\nhead(lottery.fac)\nboxplot(lottery.payoff~classes, data=lottery.fac, main=\"Payoff by Numbers Drawn\")\n```\n\n- boxplot() 대신에 그냥 plot()을 하면 어떻게 되는지 시도해 볼 것. 차이점은?\n\n- 이제 산점도에 각 변수의 주변분포(marginal distribution)를 표시해 보자. 당첨번호는 히스토그램으로, 당첨금액은 boxplot 으로 그려 본다. \n\n```{r fig.width=8, fig.height=6}\nopar<-par(no.readonly=TRUE)\npar(fig=c(0,0.8,0,0.8))\nplot(lottery.payoff~lottery.number, data=lottery.fac, pch=20, xlab=\"Numbers Drawn\", ylab=\"Payoff in Dollars\")\npar(fig=c(0,0.8,0.55,1), new=TRUE)\nhist(lottery.number, axes=F, ann=F)\npar(fig=c(0.65,1,0,0.8), new=TRUE)\nboxplot(lottery.payoff, horiz=TRUE, axes=F)\n```\n\n- 만일 boxplot 대신에 히스토그램을 눕혀 그리고 싶다면, hist()에는 horiz= 이 없기 때문에 barplot()에서 설정해 주어야 함. 일단, 그려보고 각각이 왜 필요한지 생각해 볼 것.\n\n```{r fig.width=8, fig.height=6}\npar(fig=c(0,0.8,0,0.8))\nplot(lottery.payoff~lottery.number, data=lottery.fac, pch=20, xlab=\"Numbers Drawn\", ylab=\"Payoff in Dollars\")\npar(fig=c(0,0.8,0.55,1), new=TRUE)\nhist(lottery.number, axes=F, ann=F)\npar(fig=c(0.7,1,0,0.8), new=TRUE)\nbarplot(table(cut(lottery.payoff, breaks=11)), horiz=T, space=0, col=\"white\", axes=F, axisnames=F)\n```\n\n- 이제 당첨금액이 높은 당첨번호들은 숫자가 중복되는 경우가 많고, 당첨번호가 0에서 100 이하인 경우에 당첨금액이 높은지 생각해 보자. detach(lottery)를 하지 않고 deatch()만 해도 되는 이유는 뭘까? save(file=filename, list=ls()) 와 같은 것이 save.image(file=filename) 임. 확인하기를^^\n\n```{r}\ndetach()\npar(opar)\nsave(file=\"lottery.RData\",list=ls())\n```\n```\nsavehistory(\"lottery.Rhistory\")\n```\n",
    "created" : 1495866810289.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "772177209",
    "id" : "9FF6172E",
    "lastKnownWriteTime" : 1495866824,
    "last_content_update" : 1495866824932,
    "path" : "~/Google 드라이브/Works/Class/Stat_Graphics/R.WD/lottery/R/lottery_bxplot_new.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}